<!DOCTYPE html> 
<html lang="el">
<head>   
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Κριτής - Σωκράτης (Σταθερή Βαθμολογία + Σχόλιο)</title>
  <style>  
    body { font-family: system-ui, Arial, sans-serif; background:#173b88; color:#fff; margin:0; display:flex; align-items:center; justify-content:center; min-height:100vh; }
    .app { background:#0e2a66; border-radius:20px; padding:20px; max-width:420px; width:100%; box-shadow:0 8px 24px rgba(0,0,0,.3); }
    h1 { font-size:22px; margin:0 0 5px 0; }
    h2 { font-size:18px; margin:0 0 12px 0; color:#cfe0ff; }
    select, textarea { width:100%; padding:10px; border-radius:10px; border:0; margin:10px 0; font-size:16px; }
    button { width:100%; padding:14px; border-radius:20px; border:0; font-size:18px; margin:10px 0; cursor:pointer; }
    .btn-primary { background:linear-gradient(135deg,#cde7ff,#caa5ff); color:#000; }
    .btn-secondary { background:linear-gradient(135deg,#6ee0ff,#3db8ff); color:#002140; }
 
  /* === Μπάρα χρόνου === */
#timeBarContainer {
  width: 100%;
  height: 10px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  margin-top: 8px;
  overflow: hidden;
}

#timeBar {
  height: 100%;
  width: 100%;
  background: linear-gradient(90deg, #4ef2a6, #f2c14e, #ef476f);
  transition: width 1s linear;
}

/* === Εφέ τελευταίων 10 δευτερολέπτων === */
@keyframes flashWarning {
  0% { filter: brightness(1); }
  50% { filter: brightness(2); }
  100% { filter: brightness(1); }
}

#timeBar.warning {
  background: linear-gradient(90deg, #ff6b6b, #ff0000);
  animation: flashWarning 1s infinite;
}

    /* === Εφέ αναπνοής για το κουμπί Σωκράτη === */
@keyframes breathe {
  0% { box-shadow: 0 0 10px #ff4d4d; }
  50% { box-shadow: 0 0 25px #ff9a9a; }
  100% { box-shadow: 0 0 10px #ff4d4d; }
}

button.recording {
  animation: breathe 2s ease-in-out infinite;
}
    
/* === Βελτιωμένη εμφάνιση πίνακα βαθμολογίας === */
.panel {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 15px;
  padding: 16px 18px;
  margin: 12px 0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  backdrop-filter: blur(4px);
  transition: 0.3s ease;
}
.panel:hover {
  background: rgba(255, 255, 255, 0.12);
}

#criteriaPanel strong {
  color: #6ee0ff;
  font-size: 17px;
}

#criteriaList {
  list-style: none;
  margin: 0;
  padding: 0;
}

#criteriaList li {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 10px;
  padding: 6px 10px;
  margin-bottom: 6px;
  font-size: 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;  /* ✅ ευθυγράμμιση bullet και κειμένου */
}

#criteriaList li::before {
  content: "•";
  color: #6ee0ff;
  margin-right: 6px;
}

#socraticComment {
  font-style: italic;
  color: #e0ecff;
  line-height: 1.5;
  font-size: 16px;
}

/* === Εμφάνιση συνολικής βαθμολογίας === */
#totalScore {
  text-align: center;
  background: linear-gradient(135deg, #ffd166, #ff7e5f);
  color: #001;
  border-radius: 20px;
  padding: 14px;
  margin-top: 15px;
  font-size: 26px;
  font-weight: 800;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

    .tiny { font-size:12px; color:#cfe0ff; opacity:.9 }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    .recording { position: relative; }
    .recording::after{
      content:"";
      position:absolute;
      top:-6px; right:-6px;
      width:12px; height:12px;
      background:#ff4d4d; border-radius:50%;
      box-shadow:0 0 0 0 rgba(255,77,77,0.7);
      animation:pulse 1.4s infinite;
    }
    @keyframes pulse{
      0%{ box-shadow:0 0 0 0 rgba(255,77,77,0.7) }
      70%{ box-shadow:0 0 0 12px rgba(255,77,77,0) }
      100%{ box-shadow:0 0 0 0 rgba(255,77,77,0) }
    }

#timerPanel {
  background: rgba(255, 255, 255, 0.15);
  font-size: 18px;
  text-align: center;
  font-weight: bold;
  margin-top: 10px;
  border-radius: 12px;
  padding: 10px;
}

    /* === Νέος σχεδιασμός βαθμολογίας === */
#socraticPanel {
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  padding: 15px;
  margin-top: 15px;
  position: relative;
  border-left: 4px solid #f2c14e;
}

.socrates-header {
  font-weight: 700;
  color: #f2c14e;
  margin-bottom: 8px;
}

.socrates-comment {
  font-style: italic;
  line-height: 1.4;
  color: #ffffff;
}

/* Κριτήρια */
#criteriaPanel {
  background: rgba(255,255,255,0.08);
  border-radius: 15px;
  margin-top: 15px;
  padding: 12px 15px;
}

.criteria-header {
  font-weight: 700;
  color: #6ee0ff;
  margin-bottom: 8px;
}

/* Συνολικό σκορ */
#scorePanel {
  text-align: center;
  background: linear-gradient(135deg,#ffd166,#ff7e5f);
  border-radius: 20px;
  padding: 12px;
  margin-top: 15px;
  color: #001;
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.score-label {
  font-size: 14px;
  font-weight: 700;
  opacity: 0.9;
}

.score-value {
  font-size: 26px;
  font-weight: 800;
}

    
#timer {
  color: #ffde59;
}

#activePlayerBar .tiny { opacity:.9; }
#activePlayerBar #bonusBtn[disabled] { opacity:.5; cursor:not-allowed; }

/* Κάνει το setup screen scrollable */
#setupScreen {
  overflow-y: auto;
  max-height: 100vh;
}

/* Εμφάνιση όταν επιλέγεται ένας χαρακτήρας */
.character.selected {
  outline: 4px solid white;
  transform: scale(1.05);
  transition: 0.2s;
}

  /* === Διάταξη χαρακτήρων σε πλέγμα === */
#characterSelection {
  display: grid !important;
  grid-template-columns: repeat(2, minmax(120px, 1fr));
  gap: 20px;
  justify-items: center;
  margin-top: 20px;
}

.character {
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  padding: 10px;
  text-align: center;
  width: 120px;
}

.character img {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: contain;
  background-color: #ffffff;
  margin-bottom: 5px;
  padding: 3px;
  transition: transform 0.2s;
}

.character img:hover {
  transform: scale(1.08);
}

.character img:hover {
  transform: scale(1.08);
}

/* 🎨 Στυλ για τα νέα κουμπιά επιλογής έκδοσης στην αρχική σελίδα */
#startSimpleBtn, #startAdvancedBtn {
  background: white;
  color: #0e2a66;
  font-weight: 600;
  transition: transform 0.2s;
}
#startSimpleBtn:hover { transform: scale(1.05); background:#d6ffe0; }
#startAdvancedBtn:hover { transform: scale(1.05); background:#ffd6d6; }

/* === Εφέ εμφάνισης popup Σωκράτη === */
#socratesPopup {
  transition: opacity 1s, transform 1s;
  opacity: 0;
  transform: translateY(20px);
}

    
/* === Εφέ εμφάνισης popup Σωκράτη === */
#socratesPopup {
  transition: opacity 1s, transform 1s;
  opacity: 0;
  transform: translateY(20px);
}

#socratesPopup.show {
  opacity: 1;
  transform: translateY(0);
}

/* ✨ Λάμψη γύρω από το πλαίσιο */
@keyframes glowPulse {
  0% { box-shadow: 0 0 10px #6ee0ff, 0 0 20px #6ee0ff; }
  50% { box-shadow: 0 0 20px #6ee0ff, 0 0 30px #6ee0ff; }
  100% { box-shadow: 0 0 10px #6ee0ff, 0 0 20px #6ee0ff; }
}

#socratesPopup.glow {
  animation: glowPulse 2s infinite alternate;
}

/* === Glow για την επιλογή Τεχνητής Νοημοσύνης === */
#useAICheckboxContainer {
  background: rgba(255,255,255,0.08);
  border-radius: 15px;
  padding: 12px 16px;
  margin-top: 20px;
  box-shadow: 0 0 10px rgba(110,224,255,0.3);
  transition: box-shadow 1.2s ease-in-out;
}

#useAICheckboxContainer:hover {
  box-shadow: 0 0 20px rgba(110,224,255,0.6);
}

@keyframes softPulse {
  0% { box-shadow: 0 0 8px rgba(110,224,255,0.3); }
  50% { box-shadow: 0 0 18px rgba(110,224,255,0.6); }
  100% { box-shadow: 0 0 8px rgba(110,224,255,0.3); }
}

#useAICheckboxContainer.glow {
  animation: softPulse 3s ease-in-out infinite;
}
    
  </style>
</head>
<body>

<!-- === ΑΡΧΙΚΗ ΟΘΟΝΗ (Welcome Screen) === -->
<div id="welcomeScreen" style="
  position:fixed;
  inset:0;
  background:linear-gradient(180deg,#102a6d,#173b88);
  color:white;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  padding:40px 20px 20px 20px;
  text-align:center;
  z-index:2000;
">
  <img src="images/Socrates.png" alt="Σωκράτης" style="width:160px;height:160px;border-radius:50%;margin-bottom:20px;object-fit:cover;">

  <h1 style="font-size:24px;margin-bottom:10px;">AI Κριτής - Σωκράτης</h1>
  <p style="font-size:15px;opacity:0.85;margin-bottom:25px;">
    Ένα φιλοσοφικό παιχνίδι επιχειρηματολογίας για παιδιά και μεγάλους.
  </p>

  <!-- === ΚΟΥΜΠΙΑ ΑΡΧΙΚΗΣ ΟΘΟΝΗΣ (Main Buttons) === -->
 <div class="button-container">
  <button id="startSimpleBtn">🟢 Απλή Έκδοση</button>
  <button id="startAdvancedBtn">🔴 Προχωρημένη Έκδοση</button>
  <button id="infoButton">ℹ️ Πληροφορίες</button>
</div>
</div>

<!-- === ΡΥΘΜΙΣΕΙΣ ΠΑΙΧΝΙΔΙΟΥ (Setup Screen) === -->
<div id="setupScreen" style="
  position:fixed;
  inset:0;
  background:rgba(10,20,60,0.95);
  color:white;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  z-index:1000;
  text-align:center;
  padding:40px 20px 20px 20px;
">

  <h1 style="margin-bottom:20px;">🎮 Ρυθμίσεις Παιχνιδιού</h1>

<!-- ✨ Ένδειξη Επιλεγμένης Έκδοσης -->
<div id="selectedModeDisplay" style="
  background: rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 10px 14px;
  margin-bottom: 20px;
  font-weight: bold;
  font-size: 16px;
  color: #6ee0ff;
">
  ✨ Επιλεγμένη Έκδοση: —
</div>
  
  <label>Αριθμός Παικτών:
    <select id="playerCount" style="margin-left:10px;">
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
    </select>
  </label>

 <div id="characterSelection" style="margin:20px 0;">

    <!-- Εδώ θα δημιουργηθούν τα avatars δυναμικά -->
  </div>

  <label>Αριθμός Γύρων:
    <select id="roundCount" style="margin-left:10px;">
      <option value="1">1</option>
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
    </select>
  </label>

   
<!-- 💡 Επιλογή Λειτουργίας Κριτή -->
<div id="useAICheckboxContainer" class="glow">
<!-- 🧠 Επιλογή Ποιος Κρίνει -->
<div id="judgeModeContainer" style="
  background: rgba(255,255,255,0.08);
  border-radius: 15px;
  padding: 12px 16px;
  margin-top: 20px;
  box-shadow: 0 0 10px rgba(242,193,78,0.3);
">
  <label style="font-size:17px; display:block; margin-bottom:6px;">Ποιος κρίνει;</label>
  <select id="judgeMode" style="width:100%; padding:8px; border-radius:10px; font-size:16px;">
    <option value="ai" selected>🤖 Τεχνητή Νοημοσύνη</option>
    <option value="offline">💻 Αυτόματος Rubric</option>
    <option value="manual">👤 Ανθρώπινος Κριτής</option>
  </select>
</div>
  
  <label style="font-size:17px; display:flex; align-items:center; gap:8px;">
    <input type="checkbox" id="useAICheckbox" checked style="transform:scale(1.3);">
    💡 Ενεργοποίηση Σωκράτη με Τεχνητή Νοημοσύνη
  </label>
  <p style="font-size:14px; opacity:0.8; margin-left:30px; margin-top:6px;">
    Απαιτεί σύνδεση στο διαδίκτυο.
  </p>
</div>
  
  <button id="startGameBtn" style="
    margin-top:30px;
    background:linear-gradient(135deg,#ffd166,#ff7e5f);
    border:0;
    border-radius:25px;
    padding:12px 30px;
    font-size:18px;
    cursor:pointer;
    color:#001;
    font-weight:bold;
  ">
    🚀 Έναρξη Παιχνιδιού
  </button>

</div>

<script>
const characters = [
  { name: "Λία", color: "#ffd166", img: "images/Lia.png" },
  { name: "Ιάσωνας", color: "#06d6a0", img: "images/Jason.png" },
  { name: "Τζέημς", color: "#118ab2", img: "images/James.png" },
  { name: "Μάρκος", color: "#ef476f", img: "images/Marco.png" },
  { name: "Άννα", color: "#a29bfe", img: "images/Anna.png" },
  { name: "Μέι Λιν", color: "#ffb6b9", img: "images/May_Lin.png" }
];

let selectedCharacters = []; // αποθηκεύει τις επιλογές

function renderCharacterSelection() {
  const container = document.getElementById("characterSelection");
  const status = document.createElement("div");
  status.id = "selectionStatus";
  status.style.marginTop = "10px";
  status.style.fontWeight = "bold";
  status.style.textAlign = "center";
  container.after(status);

  container.innerHTML = "";
  characters.forEach(ch => {
    const btn = document.createElement("button");
    btn.innerHTML = `
      <img src="${ch.img}" style="width:60px;height:60px;border-radius:50%;display:block;margin:0 auto 5px;">
      ${ch.name}
    `;
    btn.style.background = ch.color;
    btn.style.border = "none";
    btn.style.color = "#000";
    btn.style.padding = "10px 15px";
    btn.style.borderRadius = "15px";
    btn.style.fontWeight = "700";
    btn.style.cursor = "pointer";
    btn.style.minWidth = "80px";

    btn.dataset.id = ch.name.toLowerCase().replace(/\s+/g,"");
btn.dataset.name = ch.name;
btn.dataset.color = ch.color;
btn.dataset.img = ch.img;
btn.classList.add("character");

btn.addEventListener("click", () => toggleCharacter(ch, btn));

    container.appendChild(btn);
  });

  updateSelectionStatus();
}

function toggleCharacter(ch, btn) {
  const playerSelect = document.getElementById("playerCount");
  const count = parseInt(playerSelect.value);
  const idx = selectedCharacters.findIndex(c => c.name === ch.name);

  if (idx !== -1) {
    
    // Αν είναι ήδη επιλεγμένος, τον αφαιρούμε
    selectedCharacters.splice(idx, 1);
    btn.style.outline = "none";
    btn.classList.remove("selected");
  } else {
    // Αν δεν είναι επιλεγμένος
    if (selectedCharacters.length >= count) {
      alert(`Μπορείς να επιλέξεις έως ${count} χαρακτήρες.`);
      return; // σταματάμε εδώ
    }
    selectedCharacters.push(ch);
    btn.style.outline = "4px solid white";
    btn.classList.add("selected");
  }

  updateSelectionStatus();
}

function updateSelectionStatus() {
  const count = parseInt(document.getElementById("playerCount").value);
  const status = document.getElementById("selectionStatus");
  status.textContent = count === 1
  ? `Έχεις επιλέξει ${selectedCharacters.length} χαρακτήρα.`
  : `Έχεις επιλέξει ${selectedCharacters.length} από ${count} χαρακτήρες.`;


const startBtn = document.getElementById("startGameBtn");
startBtn.disabled = selectedCharacters.length < count;
startBtn.style.opacity = startBtn.disabled ? "0.5" : "1";
}
renderCharacterSelection();

document.getElementById("playerCount").addEventListener("change", () => {
  // Αν μειωθεί ο αριθμός παικτών και έχουμε παραπάνω χαρακτήρες, αφαίρεσέ τους
  const count = parseInt(document.getElementById("playerCount").value);
  if (selectedCharacters.length > count) {
    selectedCharacters = selectedCharacters.slice(0, count);
  }
  // Αφαίρεσε τα outlines από όσους “κόπηκαν”
  document.querySelectorAll(".character").forEach(btn => {
    const name = btn.textContent.trim();
    if (!selectedCharacters.find(c => c.name === name)) {
      btn.style.outline = "none";
      btn.classList.remove("selected");
    }
  });
  updateSelectionStatus();
  // ✅ Αν ο αριθμός παικτών είναι 6, επίλεξε αυτόματα όλους τους χαρακτήρες
if (count === 6) {
  selectedCharacters = [...characters];
  document.querySelectorAll(".character").forEach(btn => {
    btn.classList.add("selected");
    btn.style.outline = "4px solid white";
  });
  updateSelectionStatus();
}
  // 🚫 Αν μειωθεί ο αριθμός παικτών κάτω από 6, αποεπιλογή όλων
if (count < 6) {
  selectedCharacters = [];
  document.querySelectorAll(".character").forEach(btn => {
    btn.classList.remove("selected");
    btn.style.outline = "none";
  });
  updateSelectionStatus();
}
});

</script>

  <div class="app">
  <h1 id="missionTitle">Αποστολή</h1>
  <h2 id="missionQuestion">—</h2>

<div class="panel" id="activePlayerBar">
  <div style="display:flex; align-items:center; gap:10px; justify-content:space-between;">
    <div style="display:flex; align-items:center; gap:10px;">
      <div id="activeAvatar" style="width:36px;height:36px;border-radius:50%;background:#cfe0ff;color:#0e2a66;display:flex;align-items:center;justify-content:center;font-weight:700;">
        Λ
      </div>
      <div>
        <div style="font-weight:700;">Ενεργός Παίκτης: <span id="activePlayerName">—</span></div>
        <div class="tiny">Γύρος: <span id="roundLabel">1</span>/<span id="roundTotal">2</span></div>
      </div>
    </div>

    <div style="display:flex; gap:8px;">
      <button class="btn-secondary" id="bonusBtn" title="Κάρτα +30″" style="min-width:90px;">+30″</button>
      <button class="btn-secondary" id="nextPlayerBtn" style="min-width:150px;">Επόμενος Παίκτης ⟶</button>
    </div>
  </div>
</div>

  <div class="row">
    <select id="missionSelect"></select>
    <select id="langSelect" title="Γλώσσα Ακρόασης">
      <option value="el-GR" selected>Ελληνικά</option>
      <option value="en-US">English</option>
    </select>
  </div>

  <textarea id="transcript" placeholder="Μίλα στο μικρόφωνο ή γράψε εδώ την απάντηση του παίκτη…"></textarea>
<p id="philosopherHint" style="
  font-size:14px;
  color:#cfe0ff;
  opacity:0.9;
  margin-top:4px;
  font-style:italic;
">
💬 Ξεκίνα αναφέροντας τον φιλόσοφό σου και τη ρήση του.<br>
Παράδειγμα: «Ο Αριστοτέλης είπε πως η φιλία είναι μία ψυχή σε δύο σώματα…»
</p>

  <button class="btn-primary" id="listenBtn">▶️ Ο Σωκράτης ακούει/διαβάζει</button>
  <button class="btn-secondary" id="scoreBtn">⚖️ Βαθμολογία</button>

    <!-- 🎧 Άκου τον Σωκράτη -->
    <button class="btn-secondary" id="speakBtn">🔊 Άκου τον Σωκράτη</button>

<p id="aiModeIndicator" style="
  text-align:center;
  font-size:14px;
  color:#6ee0ff;
  margin-top:-5px;
  margin-bottom:10px;
  opacity:0.85;
">
  🤖 Ο Σωκράτης λειτουργεί με Τεχνητή Νοημοσύνη
</p>
  
<div class="panel" id="timerPanel">
  ⏳ Χρόνος: <span id="timer">1:30</span>
  <div id="timeBarContainer">
    <div id="timeBar"></div>
  </div>
</div>

<p id="judgeModeIndicator" style="
  text-align:center;
  font-size:13px;
  color:#ffd166;
  margin-top:-6px;
  margin-bottom:10px;
  opacity:0.85;
">
  Λειτουργία: 🤖 AI Κριτής (API)
</p>
    
<!-- 💬 Σχόλιο Σωκράτη -->
<div class="panel" id="socraticPanel">
  <div class="socrates-header">💬 Ο Σωκράτης σχολιάζει:</div>
  <div id="socraticComment" class="socrates-comment">—</div>
</div>

<!-- ⚖️ Ανάλυση Βαθμολογίας -->
<div class="panel" id="criteriaPanel">
  <div class="criteria-header">⚖️ Ανάλυση Βαθμολογίας</div>
  <ul id="criteriaList"></ul>
</div>

<!-- 🌟 Συνολικό Σκορ -->
<div id="scorePanel">
  <div class="score-label">Συνολική Βαθμολογία</div>
  <div class="score-value" id="totalScore">—/8</div>
</div>

<script>

/* ---------- Timer (globals first) ---------- */
let timerInterval = null;
let isTimerRunning = false;
let remainingTime = 90;
let isPaused = false;
let useAI = false;  // ✅ Ελέγχει αν ο Σωκράτης θα λειτουργήσει με ΤΝ
let judgeMode = "ai"; // ai | offline | manual

  /* ---------- Έκδοση Παιχνιδιού ---------- */
const SOCRATES_VERSION = "1.3-stable"; // ενημερώνεις εδώ κάθε φορά που κάνουμε αλλαγές

  
/* ---------- Missions ---------- */
const missions = [
  {id:"M-001",title:"Δίκαιο",question:"Τι είναι δίκαιο;"},
  {id:"M-002",title:"Φιλία",question:"Τι σημαίνει να είμαι φίλος;"},
  {id:"M-003",title:"Επιτυχία",question:"Γιατί δεν μπορώ να τα έχω όλα;"},
  {id:"M-004",title:"Ευγνωμοσύνη",question:"Γιατί λέμε \"ευχαριστώ\";"},
  {id:"M-005",title:"Αλήθεια",question:"Πρέπει πάντα να λέμε την αλήθεια;"},
  {id:"M-006",title:"Θάρρος",question:"Τι σημαίνει να είσαι γενναίος;"},
  {id:"M-007",title:"Αποδοχή Ήττας",question:"Είναι δίκαιο να χάνω;"},
  {id:"M-008",title:"Αγάπη",question:"Πώς δείχνουμε ότι αγαπάμε;"},
  {id:"M-009",title:"Κανόνες",question:"Γιατί υπάρχουν κανόνες;"},
  {id:"M-010",title:"Ευτυχία",question:"Τι σε κάνει πραγματικά χαρούμενο;"},
  {id:"M-011",title:"Ελπίδα/Όνειρα",question:"Γιατί είναι σημαντικό να ονειρεύεσαι;"},
  {id:"M-012",title:"Πραγματικότητα",question:"Τι είναι αληθινό;"},
  {id:"M-013",title:"Σεβασμός",question:"Πώς δείχνεις σεβασμό;"},
  {id:"M-014",title:"Αυτοσυνείδηση",question:"Πώς ξέρω ποιος είμαι;"},
  {id:"M-015",title:"Ζήλεια",question:"Είναι κακό να ζηλεύω;"},
  {id:"M-016",title:"Καλοσύνη",question:"Τι σημαίνει να είμαι καλός;"},
  {id:"M-017",title:"Ελευθερία",question:"Τι είναι η Ελευθερία;"},
  {id:"M-018",title:"Ψυχή",question:"Υπάρχει Ψυχή;"},
  {id:"M-019",title:"Νόημα της Ζωής",question:"Έχει νόημα η Ζωή;"},
  {id:"M-020",title:"Σωστό-Λάθος",question:"Ποιος αποφασίζει τι είναι σωστό;"},
  {id:"M-021",title:"Τεχνητή Νοημοσύνη",question:"Πόση Τεχνητή Νοημοσύνη είναι αρκετή;"}
];

/* ---------- Εικόνες Φιλοσόφων ---------- */
const philosopherImages = {
  "Πλάτων": "images/philosophers/Plato.png",
  "Αριστοτέλης": "images/philosophers/Aristotle.png",
  "Σωκράτης": "images/philosophers/Socrates.png",
  "Επίκουρος": "images/philosophers/Epicurus.png",
  "Επίκτητος": "images/philosophers/Epictetus.png"
};
   
/* ---------- Ρήσεις ανά Αποστολή ---------- */
const quotesByMission = {
  "M-001": [
    { author: "Πλάτων", quote: "Ο δίκαιος άνθρωπος δεν βλάπτει ποτέ κανέναν. (Πολιτεία)" },
    { author: "Αριστοτέλης", quote: "Το δίκαιο είναι η αρχή της πολιτικής αρετής. (Ηθικά Νικομάχεια)" }
  ],
  "M-002": [
    { author: "Αριστοτέλης", quote: "Η φιλία είναι μία ψυχή σε δύο σώματα." },
    { author: "Επίκουρος", quote: "Από όλα όσα η σοφία μάς χαρίζει για την ευτυχία, το πολυτιμότερο είναι η φιλία." }
  ],
  "M-005": [
    { author: "Πλάτων", quote: "Η αλήθεια είναι ο ήλιος του νου." },
    { author: "Σωκράτης", quote: "Ένα μόνο ξέρω: ότι δεν ξέρω τίποτα. (Απολογία)" }
  ],
  "M-006": [
    { author: "Αριστοτέλης", quote: "Η ανδρεία είναι το μέσο ανάμεσα στον φόβο και την τόλμη." }
  ],
  "M-010": [
    { author: "Αριστοτέλης", quote: "Η ευτυχία είναι το τελικό αγαθό στο οποίο αποβλέπουν όλες οι πράξεις μας." },
    { author: "Επίκουρος", quote: "Η ευτυχία δεν έρχεται με τα πλούτη, αλλά με τη γαλήνη της ψυχής." }
  ],
  "M-017": [
    { author: "Επίκτητος", quote: "Ελεύθερος είναι όποιος δεν εξαρτάται από τα πάθη του." },
    { author: "Πλάτων", quote: "Η ελευθερία είναι η τάξη της ψυχής που γνωρίζει το δίκαιο." }
  ],
  "M-019": [
    { author: "Αριστοτέλης", quote: "Το νόημα της ζωής είναι να βρεις τον σκοπό σου και να του αφιερωθείς." },
    { author: "Σωκράτης", quote: "Μη ζεις χωρίς να εξετάζεις τη ζωή σου. (Απολογία)" }
  ]
};

/* ---------- (Απενεργοποιημένο) Παλαιό RUBRIC ---------- 
const RUBRIC = {
  order: ["Θέση", "Τεκμηρίωση", "Συνάφεια", "Σαφήνεια", "Αντίρρηση"],
  weights: {
    "Θέση":       { min: 0, max: 2 },
    "Τεκμηρίωση": { min: 0, max: 2 },
    "Συνάφεια":   { min: 0, max: 2 },
    "Σαφήνεια":   { min: 0, max: 2 },
    "Αντίρρηση":  { min: 0, max: 2 }
  },
  maxPerRound: 8
};
---------- ΤΕΛΟΣ ΠΑΛΑΙΟΥ RUBRIC ---------- */

/* ---------- Manual Rubric (φορτώνεται από εξωτερικό αρχείο) ---------- */
let MANUAL_RUBRIC = { criteria: [] };

async function loadRubric() {
  try {
    const response = await fetch("data/rubricWeights.json");
    if (!response.ok) throw new Error("Αποτυχία φόρτωσης rubricWeights.json");
    const data = await response.json();
    MANUAL_RUBRIC = data;
    console.log("📘 Rubric φορτώθηκε επιτυχώς:", MANUAL_RUBRIC);
  } catch (err) {
    console.error("⚠️ Σφάλμα στη φόρτωση rubricWeights.json:", err);
  }
}

function getActiveManualCriteria(gameMode, currentRound) {
  const isFirstRound = currentRound === 1;
  const isSimple = (gameMode || "simple") === "simple";
  return MANUAL_RUBRIC.criteria.filter(c => {
    const roundOK = isFirstRound ? c.rounds.first : c.rounds.later;
    const modeOK  = isSimple ? c.simple : c.advanced;
    return roundOK && modeOK;
  });
}


function getActiveManualCriteria(gameMode, currentRound) {
  const isFirstRound = currentRound === 1;
  const isSimple = (gameMode || "simple") === "simple";
  return MANUAL_RUBRIC.criteria.filter(c => {
    const roundOK = isFirstRound ? c.rounds.first : c.rounds.later;
    const modeOK  = isSimple ? c.simple : c.advanced;
    return roundOK && modeOK;
  });
}
  

/* ---------- Game state ---------- */
const game = {
  players: [
    { id: 'p1', name: 'Λία', color: '#ffd166', bonusLeft: 1 },
    { id: 'p2', name: 'Ιάσωνας', color: '#06d6a0', bonusLeft: 1 }
  ],
  currentRound: 1,
  totalRounds: 2,
  activeIndex: 0,
  baseTimeSec: 90,
   scores: {}   // ✅ εδώ δηλώνουμε τον χώρο όπου θα αποθηκεύονται οι βαθμολογίες
};

  /* ---------- Μνήμη Θέσεων Φιλοσόφων ---------- */
// Αποθηκεύει για κάθε παίκτη τη φιλοσοφική του θέση (μόνο την πρώτη φορά)
const playerPositions = {};
  
function renderActivePlayer() {
  const p = game.players[game.activeIndex];
  document.getElementById('activePlayerName').textContent = p.name;

  // Εμφάνιση εικόνας φιλοσόφου ή fallback γράμμα
const avatar = document.getElementById('activeAvatar');
if (p.img) {
  avatar.innerHTML = `
    <img src="${p.img}" alt="${p.name}" 
      style="width:100%;height:100%;border-radius:50%;object-fit:cover;
      border:3px solid ${p.color || '#6ee0ff'};box-shadow:0 0 10px ${p.color || '#6ee0ff'};">
  `;
} else {
  avatar.textContent = p.name[0] || 'Π';
  avatar.style.color = "#0e2a66";
}

  document.getElementById('activeAvatar').style.background = p.color || '#cfe0ff';
  document.getElementById('roundLabel').textContent = game.currentRound;
  document.getElementById('roundTotal').textContent = game.totalRounds;
  const bonusBtn = document.getElementById('bonusBtn');
  bonusBtn.disabled = p.bonusLeft <= 0;
}

/* ---------- Ενημέρωση ενδείξεων λειτουργίας Κριτή ---------- */
function updateJudgeModeIndicator(mode) {
  const topText = document.getElementById("aiModeIndicator");
  const bottomText = document.getElementById("judgeModeIndicator");

  if (!topText || !bottomText) return;

  if (mode === "ai") {
    topText.innerHTML = "🧠 Ο Σωκράτης συλλογίζεται με τη βοήθεια Τεχνητής Νοημοσύνης.";
    bottomText.innerHTML = "Λειτουργία: 🤖 AI Κριτής (API)";
  }
  else if (mode === "offline") {
    topText.innerHTML = "💻 Ο Σωκράτης αξιολογεί βάσει του rubric του παιχνιδιού.";
    bottomText.innerHTML = "Λειτουργία: 💻 Τοπικός Κριτής";
  }
  else if (mode === "manual") {
    topText.innerHTML = "✍️ Η βαθμολόγηση γίνεται χειροκίνητα — βαθμολογεί ο παίκτης που έχετε επιλέξει!";
    bottomText.innerHTML = "Λειτουργία: ✍️ Χειροκίνητη Αξιολόγηση";
  }
  else {
    topText.innerHTML = "⚖️ Επιλέξτε τρόπο αξιολόγησης.";
    bottomText.innerHTML = "—";
  }

  console.log(`⚙️ Ενημερώθηκε λειτουργία κριτή σε: ${mode}`);
}

  
function loadMissions(){
  const sel = document.getElementById("missionSelect");
  sel.innerHTML = "";
  missions.forEach(m=>{
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = `${m.id} — ${m.title}`;
    sel.appendChild(opt);
  });
  renderMission(missions[0].id);
}

  /* ---------- Φόρτωση Ρήσεων Φιλοσόφων από εξωτερικό αρχείο ---------- */
async function loadPhilosopherPositions(missionId) {
  try {
   const base = window.location.origin;
const response = await fetch(`${base}/data/philosopherPositions.json`);
    console.log("🔍 Απάντηση από server:", response.url, response.status);
    const allData = await response.json();

    if (!allData[missionId]) {
      console.warn(`Δεν υπάρχουν δεδομένα για ${missionId}`);
      return [];
    }

    const philosophers = Object.entries(allData[missionId]).map(([name, quote]) => ({
      name,
      quote
    }));

    console.log("📜 Ρήσεις Φιλοσόφων:", philosophers);
    return philosophers;

  } catch (err) {
    console.error("Σφάλμα στη φόρτωση philosopherPositions.json:", err);
    return [];
  }
}

/* ---------- Φόρτωση Εκφράσεων και Μηνυμάτων Ανατροφοδότησης ---------- */
let argumentPatterns = {};
let feedbackMessages = {};

async function loadArgumentPatterns() {
  try {
    const response = await fetch("https://ai-kritis-demo.vercel.app/data/argumentPatterns.json");
    argumentPatterns = await response.json();
    console.log("🧠 Εκφράσεις επιχειρημάτων φορτώθηκαν:", argumentPatterns);
  } catch (err) {
    console.error("Σφάλμα στη φόρτωση argumentPatterns.json:", err);
  }
}

async function loadFeedbackMessages() {
  try {
    const response = await fetch("https://ai-kritis-demo.vercel.app/data/feedbackMessages.json");
    feedbackMessages = await response.json();
    console.log("💬 Μηνύματα ανατροφοδότησης φορτώθηκαν:", feedbackMessages);
  } catch (err) {
    console.error("Σφάλμα στη φόρτωση feedbackMessages.json:", err);
  }
}

/* Εκτελούμε και τα δύο όταν φορτώνει η σελίδα */
window.addEventListener("load", async () => {
  await Promise.all([
    loadArgumentPatterns(),
    loadFeedbackMessages()
  ]);
});
  
function renderMission(id){
  const m = missions.find(x=>x.id===id);
  document.getElementById("missionTitle").textContent = `Αποστολή ${m.id}`;
  document.getElementById("missionQuestion").textContent = `${m.title}: ${m.question}`;
  // 📖 Φόρτωση ρήσεων φιλοσόφων για τη συγκεκριμένη αποστολή
  loadPhilosopherPositions(id).then(data => {
    if (data.length > 0) {
      const first = data[0];
      document.getElementById("philosopherHint").innerHTML =
        `💬 Ξεκίνα αναφέροντας τον φιλόσοφό σου και τη ρήση του.<br>Παράδειγμα: «${first.name} είπε: ${first.quote}»`;
    }
  });
 
  document.getElementById("missionSelect").value = id;
}

/* ---------- Έλεγχος παρουσίας εκφράσεων (pattern detection) ---------- */
function checkPatterns(answerText, patterns) {
  const text = answerText.toLowerCase();
  const found = {};

  for (const [category, expressions] of Object.entries(patterns)) {
    found[category] = expressions.some(expr => text.includes(expr));
  }

  return found;
}

/* ---------- Τυχαία Σχόλια Σωκράτη ---------- */
const socratesComments = [
  "Η σιωπή είναι κι αυτή μια απάντηση.",
  "Καλή σκέψη, αλλά μήπως έχει κι άλλη όψη;",
  "Ο διάλογος ανοίγει τον δρόμο της σοφίας.",
  "Η αλήθεια γεννιέται μέσα από ερωτήσεις.",
  "Ο Σωκράτης χαμογελά – προχώρα έτσι!",
  "Μερικές φορές, η γνώση ξεκινά από την απορία.",
  "Σκέψου ξανά: ποιο είναι το γιατί πίσω από αυτό;",
  "Κάθε ιδέα αξίζει να ακουστεί."
];
  
/* ---------- Εμφάνιση Popup Σωκράτη ---------- */
function showSocratesPopup() {
  const random = Math.floor(Math.random() * socratesComments.length);
  const message = socratesComments[random];
  const popup = document.getElementById("socratesPopup");
  const text = document.getElementById("socratesPopupText");

  text.textContent = message;
  popup.style.display = "block";

  // ✨ Προσθήκη κλάσεων για εφέ εμφάνισης & λάμψης
  popup.classList.add("show", "glow");

  // Μετά από 3 δευτερόλεπτα fade out
  setTimeout(() => {
    popup.classList.remove("glow");
    popup.style.opacity = 0;
    popup.style.transform = "translateY(20px)";
    setTimeout(() => {
      popup.style.display = "none";
      popup.classList.remove("show");
    }, 1000);
  }, 3000);
}

/* ---------- Advance turn & round ---------- */
function advanceTurn() {
  const isLastPlayer = game.activeIndex === game.players.length - 1;
  const isLastRound = game.currentRound === game.totalRounds;

  // ✅ Αν είναι ο τελευταίος παίκτης του τελευταίου γύρου,
  // πρώτα αποθηκεύουμε ό,τι υπάρχει και μετά δείχνουμε τα αποτελέσματα
  if (isLastPlayer && isLastRound) {
    console.log("📜 Όλοι οι παίκτες ολοκλήρωσαν! Εμφάνιση τελικής κάρτας...");
    showResultsSummary();
    return;
  }

  // Διαφορετικά, προχωράμε κανονικά στον επόμενο παίκτη ή γύρο
  game.activeIndex++;

  // Αν περάσαμε τον τελευταίο παίκτη, πάμε στον πρώτο του επόμενου γύρου
  if (game.activeIndex >= game.players.length) {
    game.activeIndex = 0;
    game.currentRound++;
    console.log(`🔁 Νέος γύρος: ${game.currentRound}/${game.totalRounds}`);
  }

  // ✅ Κλήση προετοιμασίας επόμενου παίκτη
  prepareNextPlayer();
} // <— ΕΔΩ ΕΚΛΕΙΝΕΙ ΤΩΡΑ Η advanceTurn()


/* ---------- Προετοιμασία επόμενου παίκτη ---------- */
function prepareNextPlayer() {
  console.log("%c⚙️ Εκτελείται prepareNextPlayer()", "color: #6ee0ff; font-weight: bold;");

  // 🧹 Καθαρισμός πεδίων πριν ξεκινήσει ο επόμενος παίκτης
  document.getElementById("transcript").value = "";
  document.getElementById("socraticComment").textContent = "—";
  document.getElementById("criteriaList").innerHTML = "";

  // ✅ Υπολογισμός σωστού παρονομαστή πριν εμφανιστεί
  const active = getActiveManualCriteria(game.mode || "simple", game.currentRound);
  const baseMax = active.reduce((s, c) => s + c.max, 0);
  const hasImageMeta = active.some(c => c.key === "Εικόνα / Μεταφορά" && c.bonus);
  const outOf = baseMax + (hasImageMeta ? 1 : 0);
  document.getElementById("totalScore").textContent = `—/${outOf}`;

  document.getElementById("timer").textContent = "1:30";

  remainingTime = game.baseTimeSec;
  clearInterval(timerInterval);
  isTimerRunning = false;
  isPaused = false;

  renderActivePlayer();
  updateTimeBar(game.baseTimeSec); // ✅ Επαναφορά μπάρας χρόνου
}

  
/* ---------- Αναλυτική Βαθμολογία (με αναλυτικά κριτήρια) ---------- */
function buildDetailsHTML() {
  let html = `<table id="detailsTable" style="width:100%;border-collapse:collapse;text-align:center;font-size:15px;">
    <thead>
      <tr style="background:rgba(255,255,255,0.1);">
        <th style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.2);">Παίκτης</th>`;

  // Δημιουργία κεφαλίδων για γύρους
  for (let r = 1; r <= game.totalRounds; r++) {
    html += `<th style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.2);">Γύρος ${r}</th>`;
  }

  html += `<th style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.2);">Σύνολο</th>
    </tr>
    </thead><tbody>`;

  // Σειρές για κάθε παίκτη
  game.players.forEach(p => {
    const arr = game.scores[p.name] || [];
    const validNumbers = arr.map(v => (typeof v === "number" ? v : 0));
    const sum = validNumbers.reduce((a, b) => a + b, 0);

    html += `<tr>
      <td style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.1);color:${p.color};font-weight:bold;">${p.name}</td>`;

    // Για κάθε γύρο, δείχνουμε σκορ και (αν υπάρχουν) τα επιμέρους κριτήρια
    for (let r = 0; r < game.totalRounds; r++) {
      const roundData = (game.criteriaDetails?.[p.name]?.[r + 1]) || {};
      const subCriteria = Object.entries(roundData)
        .map(([k, v]) => `${k}: ${v}`)
        .join("<br>");
      html += `<td style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.1);font-size:13px;">
        <b>${validNumbers[r] ?? "—"}</b><br><span style="opacity:0.8;font-size:12px;">${subCriteria || ""}</span>
      </td>`;
    }

    html += `<td style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.1);font-weight:bold;">${sum}</td></tr>`;
  });

  html += `</tbody></table>`;
  return html;
}
  
function showResultsSummary() {
  const totalScores = {};
  const playerSummaries = [];

  // 🔹 Υπολογισμός πόντων για κάθε παίκτη
  game.players.forEach(p => {
    const arr = game.scores[p.name] || [];
    const validNumbers = arr.filter(n => typeof n === "number" && !isNaN(n));

    const roundScores = validNumbers.map((n, i) => `Γύρος ${i + 1}: ${n}/8`);
    const sum = validNumbers.reduce((a, b) => a + b, 0);

    totalScores[p.name] = sum;

    playerSummaries.push(`
      <li style="margin-bottom:12px;">
        <strong style="color:${p.color}">${p.name}</strong><br>
        <span style="font-size:14px;opacity:0.9">${roundScores.join(" | ")}</span><br>
        <span style="font-size:15px;">Σύνολο: <b>${sum}</b></span>
      </li>
    `);
  });

  // ✅ Επιλογή ρήσης και εικόνας φιλοσόφου
  const currentMission = document.getElementById("missionSelect").value;
  const availableQuotes = quotesByMission[currentMission] || [];

  let quoteHTML = ""; // χωρίς fallback

  if (availableQuotes.length > 0) {
    const random = Math.floor(Math.random() * availableQuotes.length);
    const q = availableQuotes[random];
    const imgSrc = philosopherImages[q.author] || "images/Socrates.png";

    quoteHTML = `
      <div style="display:flex; align-items:center; justify-content:center; gap:16px; flex-wrap:wrap;">
        <div style="position:relative; width:90px; height:90px;">
    <img src="${imgSrc}" alt="${q.author}"
     style="width:90px;height:90px;border-radius:50%;
     object-fit:cover;border:3px solid #6ee0ff;background:none;box-shadow:0 0 10px #6ee0ff;">
        </div>
        <div style="max-width:420px; text-align:left;">
          <p style="font-style:italic; font-size:18px; margin:0;">«${q.quote}»</p>
          <p style="text-align:right; margin-top:6px; font-weight:bold;">— ${q.author}</p>
        </div>
      </div>
    `;
  }

  document.getElementById("socratesQuote").innerHTML = quoteHTML;

  // 🏆 Εύρεση νικητή
  let winnerText = "—";
  const entries = Object.entries(totalScores);
  if (entries.length > 0) {
    // Υπολογισμός νικητή ή ισοβαθμίας
entries.sort((a, b) => b[1] - a[1]);
const highest = entries[0][1];
const winners = entries.filter(([_, score]) => score === highest).map(([name]) => name);

if (winners.length === 1) {
  winnerText = `🏆 Νικητής: ${winners[0]} με σύνολο ${highest} πόντους!`;
} else {
  winnerText = `🤝 Ισοβαθμία μεταξύ: ${winners.join(", ")} με σύνολο ${highest} πόντους!`;
}
  } else {
    winnerText = "Δεν υπάρχουν καταχωρημένα σκορ.";
  }

  // 📋 Δημιουργία λίστας αποτελεσμάτων
  const html = `
    <ul style="list-style:none; padding:0; text-align:left; margin-top:15px;">
      ${playerSummaries.join("")}
    </ul>
    <p style="margin-top:15px; font-size:17px;">${winnerText}</p>
  `;

  // 🪄 Εμφάνιση modal
  document.getElementById("resultsSummary").innerHTML = html;
  document.getElementById("resultModal").style.display = "flex";

  // 🔔 Ήχος - Σωκράτειο Καμπανάκι
  try {
    const audio = new Audio("sounds/philosophical_chime.mp3");
    audio.volume = 0.6;
    audio.currentTime = 0;
    audio.play().catch(err => console.warn("Audio blocked:", err));

    const modalBox = document.querySelector("#resultModal > div");
    if (modalBox) {
      modalBox.classList.add("glow");
      setTimeout(() => modalBox.classList.remove("glow"), 1500);
    }
  } catch (e) {
    console.warn("Audio failed:", e);
  }

  // 🔁 Επόμενη Αποστολή → Επιστροφή στην αρχική
  document.getElementById("nextMissionBtn").onclick = () => {
    document.getElementById("resultModal").style.display = "none";
    document.getElementById("welcomeScreen").style.display = "flex";
    document.getElementById("setupScreen").style.display = "none";
    document.querySelector(".app").scrollIntoView({ behavior: "smooth" });
    game.scores = {};
    game.currentRound = 1;
    game.activeIndex = 0;
    renderActivePlayer();
  };
}
  
/* === ΝΕΕΣ ΒΟΗΘΗΤΙΚΕΣ ΣΥΝΑΡΤΗΣΕΙΣ === */
function updateTimeBar(durationSec) {
  const bar = document.getElementById("timeBar");
  if (!bar || !durationSec) return;
  const progress = Math.max(0, (remainingTime / durationSec) * 100);
  bar.style.width = progress + "%";
}

function zeroTimer() {
  clearInterval(timerInterval);
  isTimerRunning = false;
  isPaused = false;
  remainingTime = 0;
  document.getElementById("timer").textContent = "0:00";
  updateTimeBar(1);
}

/* === ΝΕΑ startTimer === */
function startTimer(durationSec = 90) {
  if (isTimerRunning && !isPaused) return; // Αν ήδη τρέχει, μην ξαναξεκινά

  clearInterval(timerInterval);
  isTimerRunning = true;
  isPaused = false;

  if (remainingTime <= 0 || remainingTime > durationSec) {
    remainingTime = durationSec;
  }

  function updateDisplay() {
    const minutes = Math.floor(remainingTime / 60);
    const seconds = remainingTime % 60;
    document.getElementById("timer").textContent =
      `${minutes}:${seconds.toString().padStart(2, "0")}`;
  }

  updateDisplay();
  updateTimeBar(durationSec);

  timerInterval = setInterval(() => {
    if (isPaused) return;
    remainingTime--;
    updateTimeBar(durationSec);

    // 🔴 Προειδοποίηση για τελευταία 10"
const bar = document.getElementById("timeBar");
if (bar) {
  if (remainingTime <= 10) bar.classList.add("warning");
  else bar.classList.remove("warning");
}

    if (remainingTime < 0) {
      clearInterval(timerInterval);
      isTimerRunning = false;
      document.getElementById("timer").textContent = "⏰ Τέλος!";

      try {
        const audio = new Audio("sounds/philosophical_chime.mp3");
        audio.volume = 0.6;
        audio.currentTime = 0;
        audio.play().catch(()=>{});
      } catch {}

      showSocratesPopup();
      try { if (recognition && recognizing) recognition.stop(); } catch {}
      advanceTurn();
      return;
    }

    updateDisplay();
  }, 1000);
}

/* ---------- Text-to-Speech (Socrates) ---------- */
document.getElementById("speakBtn").addEventListener("click", ()=>{
  const comment = document.getElementById("socraticComment").textContent.trim();
  if(!comment || comment==="—"){ 
    alert("Δεν υπάρχει σχόλιο για να διαβαστεί.");
    return;
  }
  const utterance = new SpeechSynthesisUtterance(comment);
  const voices = speechSynthesis.getVoices();
  const greekVoice = voices.find(v => v.lang.startsWith("el"));
  if(greekVoice) utterance.voice = greekVoice;
  speechSynthesis.speak(utterance);
});

/* ---------- Speech-to-Text ---------- */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
let recognizing = false;
let finalTranscript = "";
let shouldListen = false;

function initSTT(){
  if(!SpeechRecognition){
    alert("Ο browser δεν υποστηρίζει Speech Recognition. Πρότεινεται Chrome σε desktop/Android.");
    return;
  }
  recognition = new SpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.lang = document.getElementById("langSelect").value;

  recognition.onstart = () => {
    recognizing = true;
    const listenBtn = document.getElementById("listenBtn");
    listenBtn.classList.add("recording");
    listenBtn.textContent = "■ Σταμάτα την ακρόαση";
    listenBtn.style.background = "linear-gradient(135deg,#ffb6b9,#ff6f61)";
    document.getElementById("timerPanel").style.opacity = "1";
  };

  recognition.onend = () => {
    recognizing = false;
    const listenBtn = document.getElementById("listenBtn");
    if (isPaused) {
      listenBtn.textContent = "⏸️ Παύση";
      listenBtn.style.background = "gray";
    } else {
      listenBtn.textContent = "▶️ Ο Σωκράτης ακούει/διαβάζει";
      listenBtn.style.background = "linear-gradient(135deg,#cde7ff,#caa5ff)";
    }
    listenBtn.classList.remove("recording");
  };

  recognition.onerror = (e) => {
    console.warn("STT error:", e.error);
  };

  recognition.onresult = (event) => {
    let interim = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const res = event.results[i];
      if (res.isFinal) finalTranscript += res[0].transcript + " ";
      else interim += res[0].transcript;
    }
    document.getElementById("transcript").value = (finalTranscript + " " + interim).trim();
  };
}

/* ---------- Listen button ---------- */
document.getElementById("listenBtn").addEventListener("click", () => {
  if (!recognition) initSTT();
  if (!recognition) return;

  const listenBtn = document.getElementById("listenBtn");
  const timerPanel = document.getElementById("timerPanel");

  if (!recognizing) {
    finalTranscript = document.getElementById("transcript").value.trim() + " ";
    recognition.lang = document.getElementById("langSelect").value;

    try { recognition.start(); } catch (err) { console.warn(err); return; }
    if (!isTimerRunning) startTimer(game.baseTimeSec || 90);

    isPaused = false;
    timerPanel.style.opacity = "1";
    removeSocratesPauseMessage();

  } else {
    isPaused = true;
    try { recognition.stop(); } catch (err) { console.warn(err); }

    timerPanel.style.opacity = "0.6";
    listenBtn.textContent = "⏸️ Παύση";
    listenBtn.style.background = "gray";
    showSocratesPauseMessage();
  }
});

/* ---------- Mission select ---------- */
document.getElementById("missionSelect").addEventListener("change", (e)=>{
  renderMission(e.target.value);
});

/* ---------- Start timer on typing ---------- */
document.getElementById("transcript").addEventListener("input", () => {
  if (!isTimerRunning) {
    startTimer(game.baseTimeSec || 90);
  }
});
  
/* ---------- Αξιολόγηση Σωκράτη (AI / Offline / Manual) ---------- */
async function getScore(transcript, mission) {
  console.log("⚙️ Εκτελείται getScore() — Λειτουργία:", judgeMode);

    // 🤖 AI Κριτής (API)
  if (judgeMode === "ai") {
    console.log("🤖 Επιλέχθηκε AI Κριτής (API Mode)");
    return await getAIScore(transcript, mission);
  }

  // 💻 Τοπικός Κριτής (Offline Rubric)
  if (judgeMode === "offline") {
    console.log("💻 Επιλέχθηκε Τοπικός Κριτής (Offline Mode)");
    return await getOfflineScore(transcript, mission);
  }

  // 👤 Ανθρώπινος Κριτής (Manual)
  if (judgeMode === "manual") {
    console.log("👤 Επιλέχθηκε Ανθρώπινος Κριτής (Manual Mode)");
    return await getManualScore();
  }

  // 1️⃣ Τοπικός Κριτής (Offline)
  if (judgeMode === 1) {
    console.log("💻 Επιλέχθηκε Τοπικός Κριτής (Offline Mode)");
    return await getOfflineScore(transcript, mission);
  }

  // 2️⃣ Ανθρώπινος Κριτής (Manual)
  if (judgeMode === 2) {
    console.log("🧑‍⚖️ Επιλέχθηκε Ανθρώπινος Κριτής (Manual Mode)");
    return await getManualScore();
  }

  // Αν δεν υπάρχει έγκυρος τρόπος
  console.warn("⚠️ Άγνωστος τρόπος Κριτή – επιστρέφεται προεπιλογή");
  return { criteria: {}, total: null, feedback: "" };
}

/* ---------- AI Κριτής (API) ---------- */
async function getAIScore(transcript, mission) {
  try {
    console.log("🧾 transcript:", transcript);
    console.log("📘 mission:", mission);

  // 🧠 Μνήμη παίκτη
const activePlayer = game.players[game.activeIndex].name;
const memory = playerPositions[activePlayer] || {};

// ✅ Δημιουργία δυναμικού prompt βάσει rubricWeights.json
const active = getActiveManualCriteria(game.mode || "simple", game.currentRound);
const rubricText = active.map(c =>
  `- ${c.key} (max ${c.max}${c.bonus ? " +1 μπόνους" : ""})`
).join("\n");

const prompt = `
Είσαι ο φιλόσοφος Σωκράτης.
Αξιολογείς την απάντηση ενός μαθητή σε μια φιλοσοφική αποστολή.

Χρησιμοποίησε τα εξής κριτήρια βαθμολόγησης:
${rubricText}

Βαθμολόγησε σε μορφή JSON όπως:
{
  "criteria": { "Θέση": 3, "Επιχειρηματολογία": 5, "Εικόνα / Μεταφορά": 4, "Αντίρρηση": 2 },
  "total": 14,
  "comment": "Εξαιρετική ανάλυση, σαφής θέση και πειστικά επιχειρήματα."
}

Απάντηση μαθητή:
${transcript}
`;

// 🚀 Κλήση API /api/score
const response = await fetch("/api/score", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    prompt,                // ✅ τώρα στέλνουμε το δυναμικό prompt
    transcript,
    mission,
    philosopher: memory.philosopher || null,
    initial_thesis: memory.thesis || null,
    round: game.currentRound,
    mode: game.mode || "simple"
  })
});

// Από εδώ και κάτω, ξεκινά η συνέχεια του κώδικα:
if (!response.ok) {
  console.error("❌ API HTTP error:", response.status);
  throw new Error("HTTP " + response.status);
}

const result = await response.json();
console.log("📨 AI Response:", result);

// ✅ Ενημέρωση του συνολικού out_of στο global αντικείμενο
window.scores = window.scores || {};
window.scores.out_of = result.out_of;
    
// Έλεγχος εγκυρότητας
if (!result || typeof result.total === "undefined") {
  throw new Error("Μη έγκυρη απάντηση από τον Σωκράτη (API)");
}

return {
  criteria: result.criteria || {},
  total: result.total,
  feedback: result.feedback || "Ο Σωκράτης σιώπησε, αλλά σκέφτηκε κάτι βαθύ…"
};

} catch (err) {
  console.error("❌ Σφάλμα στη βαθμολόγηση:", err);
  // Fallback στον offline κριτή
  return await getOfflineScore(transcript, mission);
}
}

  
/* ---------- Επιλογή τρόπου Κριτή ---------- */
// ai = API, offline = Τοπικός (rubric), manual = Ανθρώπινος Κριτής

function setJudgeMode(mode) {
  judgeMode = mode;
  const modeNames = {
    ai: "🤖 AI Κριτής (API)",
    offline: "💻 Τοπικός Κριτής (Rubric)",
    manual: "👤 Ανθρώπινος Κριτής"
  };
  console.log(`⚙️ Επιλέχθηκε: ${modeNames[mode] || "Άγνωστος Κριτής"}`);
  const indicator = document.getElementById("judgeModeIndicator");
  if (indicator) {
    indicator.textContent = `Λειτουργία: ${modeNames[mode] || "—"}`;
  }
}

/* ---------- Τοπικός Κριτής (Offline / Local) ---------- */
async function getOfflineScore(transcript, mission) {
  // ✅ Ανάκτηση ενεργών κριτηρίων από το rubricWeights.json
  const active = getActiveManualCriteria(game.mode || "simple", game.currentRound);

  // Αν δεν υπάρχουν, επιστρέφει μηδενικά
  if (!active.length) {
    return {
      criteria: {},
      total: 0,
      out_of: 0,
      comment: "Δεν εντοπίστηκαν ενεργά κριτήρια για αυτόν τον γύρο."
    };
  }

  // ✅ Ανάκτηση πραγματικών μέγιστων τιμών rubric (για έλεγχο και ομοιομορφία)
  let rubricMax = {};
  try {
    const res = await fetch("data/rubricWeights.json");
    const json = await res.json();
    json.criteria.forEach(c => {
      rubricMax[c.key] = c.max;
    });
  } catch (err) {
    console.warn("⚠️ Δεν βρέθηκε rubricWeights.json — χρήση default τιμών.");
    active.forEach(c => rubricMax[c.key] = c.max);
  }

  // ✅ Βαθμολόγηση βάσει εμφάνισης λέξεων-δεικτών
  let totalScore = 0;
  const results = {};
  const lower = transcript.toLowerCase();

  for (const c of active) {
    let score = 0;

    if (c.key.includes("Θέση")) {
      if (lower.includes("πιστεύω") || lower.includes("θεωρώ")) score = rubricMax[c.key] * 0.5;
      if (lower.includes("ο φιλόσοφος") || lower.includes("λέει")) score = rubricMax[c.key];
    }

    else if (c.key.includes("Επιχειρηματολογία")) {
      if (lower.includes("γιατί") || lower.includes("επειδή")) score = rubricMax[c.key] * 0.5;
      if (lower.includes("άρα") || lower.includes("συνεπώς")) score = rubricMax[c.key];
    }

    else if (c.key.includes("Εικόνα")) {
      if (lower.includes("όπως")) score = rubricMax[c.key] * 0.5;
      if (lower.includes("σαν") || lower.includes("μοιάζει")) score = rubricMax[c.key];
    }

    else if (c.key.includes("Παράδειγμα")) {
      if (lower.includes("παράδειγμα") || lower.includes("όπως")) score = rubricMax[c.key];
    }

    else if (c.key.includes("Αντίρρηση")) {
      if (lower.includes("δεν συμφωνώ") || lower.includes("όμως")) score = rubricMax[c.key] * 0.5;
      if (lower.includes("αντίθετα") || lower.includes("αντίρρηση")) score = rubricMax[c.key];
    }

    results[c.key] = Math.round(score);
    totalScore += score;
  }

  // ✅ Υπολογισμός συνολικού παρονομαστή
  const outOf = active.reduce((sum, c) => sum + (rubricMax[c.key] || c.max), 0);

  // ✅ Δημιουργία σχολίου
  let comment = "Καλή προσπάθεια!";
  if (totalScore >= outOf * 0.8)
    comment = "Εξαιρετική απάντηση! Ο Σωκράτης θα ήταν περήφανος.";
  else if (totalScore < outOf * 0.4)
    comment = "Χρειάζεται περισσότερη τεκμηρίωση και παραδείγματα.";

    // 🧮 Καταγραφή αποτελεσμάτων για debugging
  const fullCriteria = {
    "Θέση": results["Θέση"] || 0,
    "Επιχειρηματολογία": results["Επιχειρηματολογία"] || 0,
    "Εικόνα / Μεταφορά": results["Εικόνα / Μεταφορά"] || 0,
    "Παράδειγμα": results["Παράδειγμα"] || 0,
    "Αντίρρηση": results["Αντίρρηση"] || 0
  };

  console.log("🧮 Offline Κριτής (τελικό αντικείμενο):", {
    criteria: fullCriteria,
    total: Math.round(totalScore),
    out_of: outOf,
    comment
  });

  return {
    criteria: fullCriteria,
    total: Math.round(totalScore),
    out_of: outOf,
    comment
  };
}


  /* ---------- Manual Rubric (Αξιολόγηση από άνθρωπο) ---------- */
async function getManualScore() {
  // 1) Προσδιορισμός ενεργών κριτηρίων με βάση Γύρο & Έκδοση
  const active = getActiveManualCriteria(game.mode || "simple", game.currentRound);

  // 2) Φτιάχνουμε δυναμικά τα inputs
  const container = document.getElementById("manualInputs");
  container.innerHTML = "";

  const isFirstRound = game.currentRound === 1;
  const roundLabel = isFirstRound
    ? "🔹 1ος γύρος (περιλαμβάνει 'Θέση', χωρίς 'Αντίρρηση')"
    : `🔸 ${game.currentRound}ος γύρος (χωρίς 'Θέση', με 'Αντίρρηση')`;

  const header = document.createElement("p");
  header.textContent = roundLabel;
  header.style.fontStyle = "italic";
  header.style.opacity = "0.9";
  container.appendChild(header);

  // Προσθήκη πεδίων ανά κριτήριο
  active.forEach(c => {
    const row = document.createElement("div");
    row.style.margin = "6px 0";

    const label = document.createElement("label");
    label.style.display = "inline-flex";
    label.style.alignItems = "center";
    label.style.gap = "6px";

    const span = document.createElement("span");
    span.textContent = `${c.key}:`;

    const input = document.createElement("input");
    input.id = `crit_${c.key}`;
    input.type = "number";
    input.min = 0;
    input.max = c.max;
    input.step = 1;
    input.value = 0;
    input.style.width = "60px";
    input.style.textAlign = "center";

    input.addEventListener("input", () => {
      if (input.value === "") return;
      let val = parseInt(input.value);
      if (isNaN(val) || val < 0) val = 0;
      if (val > c.max) val = c.max;
      input.value = val;
    });

    label.appendChild(span);
    label.appendChild(input);
    label.insertAdjacentHTML("beforeend", ` /${c.max}`);

    row.appendChild(label);
    container.appendChild(row);

    // Αν είναι Εικόνα/Μεταφορά και έχει bonus, βάζουμε checkbox για +1
    if (c.key === "Εικόνα / Μεταφορά" && c.bonus) {
      const b = document.createElement("div");
      b.style.fontSize = "13px";
      b.style.opacity = "0.9";
      b.style.marginLeft = "6px";
      b.innerHTML = `
        <label style="display:inline-flex; align-items:center; gap:6px; margin-top:4px;">
          <input type="checkbox" id="bonus_image_meta" />
          +${c.bonus} μπόνους (χρησιμοποιήθηκαν <b>και</b> Εικόνα <u>και</u> Μεταφορά)
        </label>`;
      container.appendChild(b);
    }
  });

  // 3) Εμφάνιση modal
  const modal = document.getElementById("manualModal");
  modal.style.display = "flex";

  // 4) Υπολογισμός out_of (περιλαμβάνει +1 στο μέγιστο όταν υπάρχει διαθέσιμο bonus)
  const baseMax = active.reduce((s, c) => s + c.max, 0);
  const hasImageMeta = active.some(c => c.key === "Εικόνα / Μεταφορά" && c.bonus);
  const outOf = baseMax + (hasImageMeta ? 1 : 0);

  // 5) Υποβολή / Ακύρωση
  return new Promise(resolve => {
    document.getElementById("manualSubmit").onclick = () => {
      const scores = {};
      let total = 0;

      // Τιμές ανά κριτήριο
      active.forEach(c => {
        const val = parseInt(document.getElementById(`crit_${c.key}`).value) || 0;
        scores[c.key] = val;
        total += val;
      });

      // Bonus για Εικόνα/Μεταφορά (αν υπάρχει checkbox και είναι τσεκαρισμένο)
      let bonus = 0;
      if (hasImageMeta) {
        const bonusEl = document.getElementById("bonus_image_meta");
        if (bonusEl && bonusEl.checked) {
          bonus = 1; // μόνο +1
          scores["Μπόνους Εικόνας/Μεταφοράς"] = 1;
        } else {
          scores["Μπόνους Εικόνας/Μεταφοράς"] = 0;
        }
      }

      total += bonus;

      modal.style.display = "none";
      resolve({
        criteria: scores,          // π.χ. { Θέση: 3, Επιχειρηματολογία: 5, ... }
        criteriaMax: Object.fromEntries(active.map(c => [c.key, c.max])), // π.χ. { Θέση: 4, ... }
        total,
        out_of: outOf,
        feedback: "📋 Οι βαθμοί καταχωρήθηκαν από τον Κριτή."
      });
    };

    document.getElementById("manualCancel").onclick = () => {
      modal.style.display = "none";
      resolve({
        criteria: {},
        criteriaMax: {},
        total: 0,
        out_of: outOf,
        feedback: "⏸️ Η αξιολόγηση ακυρώθηκε."
      });
    };
  });
}


/* ---------- Score button ---------- */
document.getElementById("scoreBtn").addEventListener("click", async ()=> {

  // 🛡️ 1. Προστασία από διπλό πάτημα
  const button = document.getElementById("scoreBtn");
  if (button.disabled) {
    console.warn("⏳ Ο Σωκράτης ήδη σκέφτεται — περίμενε λίγο!");
    return;
  }

  // 🚫 Αν έχει ήδη ολοκληρώσει αυτόν τον γύρο, μην επιτρέπεις νέα βαθμολογία
  const currentPlayer = game.players[game.activeIndex].name;
  if (game.completedRounds?.[currentPlayer]?.includes(game.currentRound)) {
    alert(`Ο ${currentPlayer} έχει ήδη ολοκληρώσει αυτόν τον γύρο.`);
    return;
  }
  
  // ⛔ Αν ο παίκτης έχει ήδη βαθμολογηθεί σε αυτόν τον γύρο
  if (
    game.scores[currentPlayer] &&
    typeof game.scores[currentPlayer][game.currentRound - 1] === "number"
  ) {
    const retry = confirm(`Ο ${currentPlayer} έχει ήδη βαθμολογηθεί σε αυτόν τον γύρο.\nΘες να επαναβαθμολογηθεί;`);
    if (!retry) return; // ❌ σταμάτα αν ο χρήστης πατήσει "Άκυρο"
  }

  // 🧠 Έλεγχος ύπαρξης ενεργού παίκτη και απάντησης
  if (!currentPlayer) {
    alert("Δεν υπάρχει ενεργός παίκτης!");
    return;
  }

  const transcript = document.getElementById("transcript").value.trim();
  if (!transcript) {
    alert("Ο Σωκράτης δεν άκουσε τίποτα για να αξιολογήσει!");
    return;
  }

  // ⚙️ 2. Ενεργοποίηση κουμπιού “Σωκράτης σκέφτεται”
  button.disabled = true;
  button.textContent = "⏳ Ο Σωκράτης σκέφτεται...";
  button.style.opacity = "0.6";

  // ⏰ 3. Auto-timeout προστασία (25")
  const safeguard = setTimeout(() => {
    if (button.disabled) {
      button.disabled = false;
      button.textContent = "⚖️ Βαθμολογία";
      button.style.opacity = "1";
      alert("⏰ Το AI καθυστέρησε πολύ. Προσπάθησε ξανά ή άλλαξε σε offline αξιολόγηση.");
    }
  }, 25000);

  console.log("🟢 Πατήθηκε το κουμπί Βαθμολογία");

  try {
    // 🧠 Διακοπή αναγνώρισης φωνής και παύση χρονόμετρου
    try { if (recognition && recognizing) recognition.stop(); } catch {}
    isPaused = false;
    zeroTimer();

    const missionId = document.getElementById("missionSelect").value;
    const mission = missions.find(m => m.id === missionId);

    // 🔹 Κλήση του αλγορίθμου αξιολόγησης
    const scores = await getScore(transcript, mission);
    clearTimeout(safeguard);

    if (!scores || scores.error) throw new Error("Μη έγκυρη απάντηση από τον Σωκράτη");

    // 💬 Σχόλιο και καθαρισμός
    let comment = scores.feedback?.trim() || "";
    if (!comment) comment = "Καλή αρχή! Δώσε λίγο περισσότερη εξήγηση στο «γιατί».";

    document.getElementById("socraticComment").textContent = comment;

// ⚖️ Εμφάνιση κριτηρίων (δυναμικά)
const criteriaList = document.getElementById("criteriaList");
criteriaList.innerHTML = "";

if (scores.criteria && Object.keys(scores.criteria).length > 0) {
  // ✅ Προβολή αναλυτικών κριτηρίων
  for (const [key, val] of Object.entries(scores.criteria)) {
    const li = document.createElement("li");

    // 🔹 Αντιστοίχιση στο rubricWeights.json για το σωστό max
    const rubricCriterion = MANUAL_RUBRIC.criteria.find(c => c.key === key);
    const max = rubricCriterion ? rubricCriterion.max : 2; // fallback = 2

    li.textContent = `${key}: ${val}/${max}`;
    criteriaList.appendChild(li);
  }
} else {
  const li = document.createElement("li");
  li.textContent = "Δεν υπάρχουν αναλυτικά στοιχεία για αυτόν τον γύρο.";
  criteriaList.appendChild(li);
}
    
   
    // 🧮 Υπολογισμός συνολικής βαθμολογίας
    let totalNum = 0;
    if (scores.total) {
      const match = String(scores.total).match(/\d+(\,\d+|\.\d+)?/);
      if (match) totalNum = parseFloat(match[0].replace(",", "."));
    }

  // ✅ Ορισμός συνολικού σκορ και δυναμικού παρονομαστή
let total = Number(scores.total ?? 0);
let out_of;

if (scores.out_of && !isNaN(scores.out_of)) {
  // Αν υπάρχει out_of από τη βαθμολόγηση, χρησιμοποίησέ το
  out_of = Number(scores.out_of);
} else {
  // Αν δεν υπάρχει, υπολόγισε από το rubric
  const active = getActiveManualCriteria(game.mode || "simple", game.currentRound);
  const baseMax = active.reduce((s, c) => s + c.max, 0);
  const hasImageMeta = active.some(c => c.key === "Εικόνα / Μεταφορά" && c.bonus);
  out_of = baseMax + (hasImageMeta ? 1 : 0);
}

document.getElementById("totalScore").textContent = `${total}/${out_of}`;

    // 💾 Αποθήκευση αποτελεσμάτων
    if (!game.scores[currentPlayer]) game.scores[currentPlayer] = [];
    game.scores[currentPlayer][game.currentRound - 1] = totalNum;
    if (!game.criteriaDetails) game.criteriaDetails = {};
    if (!game.criteriaDetails[currentPlayer]) game.criteriaDetails[currentPlayer] = {};
    game.criteriaDetails[currentPlayer][game.currentRound] = scores.criteria || {};

    // ✅ Κλείδωμα παίκτη μετά τη βαθμολόγηση
    if (!game.completedRounds) game.completedRounds = {};
    if (!game.completedRounds[currentPlayer]) game.completedRounds[currentPlayer] = [];
    game.completedRounds[currentPlayer].push(game.currentRound);

   console.log(`✅ Βαθμολογία ${currentPlayer}: ${totalNum}/8`);

  } catch (err) {
    console.error("❌ Σφάλμα στη βαθμολόγηση:", err);
    alert("⚠️ Παρουσιάστηκε σφάλμα στη σύνδεση με τον Σωκράτη. Προσπάθησε ξανά!");
  } finally {
    // 🧹 Επαναφορά κουμπιού
    button.disabled = false;
    button.textContent = "⚖️ Βαθμολογία";
    button.style.opacity = "1";
  }
});


/* ---------- Next player / Bonus ---------- */
document.getElementById('nextPlayerBtn').addEventListener('click', ()=>{
  // ⛔ Έλεγχος: δεν μπορείς να πας στον επόμενο χωρίς βαθμολογία
  const currentPlayer = game.players[game.activeIndex].name;
  const roundIndex = game.currentRound - 1;

  if (
    !game.scores[currentPlayer] ||
    typeof game.scores[currentPlayer][roundIndex] !== "number"
  ) {
    alert(`Πρέπει πρώτα να βαθμολογήσεις τον ${currentPlayer} πριν συνεχίσεις!`);
    return;
  }
 
  clearInterval(timerInterval);
  isTimerRunning = false;
  isPaused = false;
  remainingTime = game.baseTimeSec; // επαναφορά χρόνου

  advanceTurn(); // ✅ ενιαία λογική αλλαγής παίκτη και γύρου
  document.getElementById("timer").textContent = "1:30";
});

document.getElementById('bonusBtn').addEventListener('click', ()=>{
  const p = game.players[game.activeIndex];
  if(p.bonusLeft > 0){
    p.bonusLeft--;
    const timerEl = document.getElementById("timer").textContent;
  if(/^\d+:\d+$/.test(timerEl)){
  const [min, sec] = timerEl.split(":").map(Number);
  remainingTime = min*60 + sec + 30;
  startTimer(remainingTime);
}
renderActivePlayer();
  }
});

/* ---------- Boot ---------- */
loadMissions();
renderActivePlayer();

/* ---------- Start Game (setup → app) ---------- */
document.getElementById("startGameBtn").addEventListener("click", () => {
  document.getElementById("welcomeScreen").style.display = "none";
  const playerCount = parseInt(document.getElementById("playerCount").value);
  const roundCount = parseInt(document.getElementById("roundCount").value);
  const useBonusEl = document.getElementById("useBonus");
  const useBonus = useBonusEl ? useBonusEl.checked : false; // ✅ ασφαλής έλεγχος
  
      // ⚙️ Ρύθμιση τρόπου Κριτή (AI / Offline / Manual)
  const judgeSelect = document.getElementById("judgeMode");
  judgeMode = judgeSelect ? judgeSelect.value : "ai"; // ✅ αν λείπει, default = "ai"
  useAI = (judgeMode === "ai");
  console.log("⚖️ Τρόπος Κριτή:", judgeMode);
  updateJudgeModeIndicator(judgeMode);

  // 🌀 Ενημέρωση ενδείξεων σε πραγματικό χρόνο όταν αλλάζει η επιλογή "Ποιος κρίνει;"
document.getElementById("judgeMode").addEventListener("change", (e) => {
  judgeMode = e.target.value;
  updateJudgeModeIndicator(judgeMode);
});

  const selected = Array.from(document.querySelectorAll(".character.selected"));
  if (selected.length < playerCount) {
    alert("Παρακαλώ επίλεξε όσους χαρακτήρες όσοι είναι οι παίκτες!");
    return;
  }

  game.players = selected.slice(0, playerCount).map(el => ({
    id: el.dataset.id,
    name: el.dataset.name,
    color: el.dataset.color,
    img: el.dataset.img,
    bonusLeft: useBonus ? 1 : 0
  }));
  game.currentRound = 1;
  game.totalRounds = roundCount;
  game.activeIndex = 0;

  document.getElementById("setupScreen").style.display = "none";
  renderActivePlayer();
});

/* ---------- Welcome → Setup (με επιλογή έκδοσης) ---------- */
async function startGame(mode) {
  // Αποθήκευση της επιλογής
  game.mode = mode;

  // ✅ Φόρτωση rubricWeights.json πριν ξεκινήσει το παιχνίδι
  if (typeof loadRubric === "function") {
    try {
      await loadRubric();
      console.log("📘 Rubric επιβεβαιώθηκε στην έναρξη παιχνιδιού.");
    } catch (err) {
      console.warn("⚠️ Δεν φορτώθηκε το rubric στην έναρξη:", err);
    }
  }

  // Απόκρυψη αρχικής και εμφάνιση setup screen
  document.getElementById("welcomeScreen").style.display = "none";
  document.getElementById("setupScreen").style.display = "flex";

  // Ενημέρωση ένδειξης στην οθόνη ρυθμίσεων
  const display = document.getElementById("selectedModeDisplay");
  if (display) {
    if (mode === "simple") {
      display.textContent = "✨ Επιλεγμένη Έκδοση: Απλή";
      display.style.color = "#7af77a";
    } else {
      display.textContent = "✨ Επιλεγμένη Έκδοση: Προχωρημένη";
      display.style.color = "#ff7a7a";
    }
  }

  // ✅ Υπολογισμός αρχικού παρονομαστή για τον πρώτο γύρο
  if (typeof prepareNextPlayer === "function") {
    prepareNextPlayer();
    console.log("%c🧮 Προετοιμάστηκε ο πρώτος παίκτης με σωστό παρονομαστή.", "color: #7af77a; font-weight: bold;");
  }
}


// ✅ Συνδέουμε τα κουμπιά της αρχικής
document.getElementById("startSimpleBtn").addEventListener("click", () => startGame("simple"));
document.getElementById("startAdvancedBtn").addEventListener("click", () => startGame("advanced"));

/* ---------- Info ---------- */
document.getElementById("infoButton").addEventListener("click", () => {
  alert("📜 Οδηγίες Παιχνιδιού:\n\n1️⃣ Επίλεξε παίκτες και γύρους.\n2️⃣ Μίλα ή γράψε την απάντηση του παίκτη.\n3️⃣ Ο Σωκράτης θα τη βαθμολογήσει και θα σχολιάσει.\n\nΚαλή διασκέδαση!");
});

function showSocratesPauseMessage() {
  removeSocratesPauseMessage(); // αν υπάρχει ήδη
  const msg = document.createElement("div");
  msg.id = "pauseMessage";
  msg.textContent = "🔇 Ο Σωκράτης δεν ακούει...";
  msg.style.position = "fixed";
  msg.style.bottom = "90px";
  msg.style.left = "50%";
  msg.style.transform = "translateX(-50%)";
  msg.style.background = "rgba(0,0,0,0.7)";
  msg.style.padding = "10px 20px";
  msg.style.borderRadius = "10px";
  msg.style.fontSize = "16px";
  msg.style.color = "#fff";
  msg.style.zIndex = "5000";
  msg.style.backdropFilter = "blur(4px)";
  document.body.appendChild(msg);
}

function removeSocratesPauseMessage() {
  const old = document.getElementById("pauseMessage");
  if (old) old.remove();
}

/* ---------- Κουμπιά για αναλυτική βαθμολογία ---------- */
window.addEventListener('DOMContentLoaded', () => {
  const detailsBtn = document.getElementById("showDetailsBtn");
  const closeBtn   = document.getElementById("closeDetailsBtn");
  const detailsModal = document.getElementById("detailsModal");
  const detailsBody  = document.getElementById("detailsBody");

  if (detailsBtn && detailsModal && detailsBody) {
    detailsBtn.addEventListener("click", () => {
      detailsBody.innerHTML = buildDetailsHTML();
      detailsModal.style.display = "flex";
    });
  }

  if (closeBtn && detailsModal) {
    closeBtn.addEventListener("click", () => {
      detailsModal.style.display = "none";
    });
  }
});
  // 🔍 Υπολογισμός ομοιότητας μεταξύ δύο απαντήσεων (πολύ απλό heuristic)
function similarityScore(a, b) {
  if (!a || !b) return 0;
  const wordsA = new Set(a.split(/\s+/));
  const wordsB = new Set(b.split(/\s+/));
  const common = [...wordsA].filter(w => wordsB.has(w)).length;
  const score = common / Math.max(wordsA.size, wordsB.size);
  return score; // 0 = καμία ομοιότητα, 1 = πανομοιότυπα
}

</script>

    <!-- 🔥 Προθέρμανση AI API -->
<script>
window.addEventListener("load", async () => {
  try {
    await fetch("/api/score", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        transcript: "ping",
        mission: { title: "prewarm", question: "test" }
      })
    });
    console.log("⚡️ Προθέρμανση API ολοκληρώθηκε");
  } catch (err) {
    console.warn("Προθέρμανση απέτυχε:", err);
  }
});
</script>
  
<!-- === MODAL ΑΝΑΚΟΙΝΩΣΗΣ ΑΠΟΤΕΛΕΣΜΑΤΟΣ === -->
<div id="resultModal" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.85);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:3000;
  color:white;
  font-family: system-ui, Arial;
  text-align:center;
  padding:20px;
">
  <div style="background:#142f70; border-radius:20px; padding:30px; max-width:600px; box-shadow:0 0 30px rgba(0,0,0,0.4);">
    <h2>📜 Η Σκέψη του Φιλοσόφου:</h2>
    <p id="socratesQuote" style="font-style:italic; font-size:1.2em; margin:20px 0;"></p>
    <h3>📜 Αποτελέσματα Αποστολής</h3>
    <div id="resultsSummary" style="margin-top:10px;"></div>
<button id="showDetailsBtn" style="
  margin-top:15px;
  background:#6ee0ff;
  border:none;
  padding:10px 22px;
  border-radius:10px;
  font-weight:bold;
  cursor:pointer;
  color:#001;
">📊 Αναλυτική Βαθμολογία</button>
    
    <button id="nextMissionBtn" style="
      margin-top:25px;
      background:#f2c14e;
      border:none;
      padding:12px 25px;
      border-radius:10px;
      font-weight:bold;
      cursor:pointer;
      color:#000;

    ">Επόμενη Αποστολή</button>
  </div>
</div>

  <!-- === MODAL ΑΝΑΛΥΤΙΚΗΣ ΒΑΘΜΟΛΟΓΙΑΣ === -->
<div id="detailsModal" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.85);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:3500;
  color:white;
  font-family:system-ui,Arial;
  text-align:center;
  padding:20px;
">
  <div style="
    background:#1a357a;
    border-radius:20px;
    padding:30px;
    max-width:600px;
    width:100%;
    box-shadow:0 0 30px rgba(0,0,0,0.4);
  ">
    <h2>📊 Αναλυτική Βαθμολογία</h2>
    <div id="detailsBody" style="margin-top:15px;text-align:left;"></div>
    <button id="closeDetailsBtn" style="
      margin-top:25px;
      background:#6ee0ff;
      border:none;
      padding:12px 25px;
      border-radius:10px;
      font-weight:bold;
      cursor:pointer;
      color:#001;
    ">Κλείσιμο</button>
  </div>
</div>

  <!-- Popup Σχολίου Σωκράτη -->
<div id="socratesPopup" style="
  display:none;
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(255,255,255,0.15);
  border:2px solid #6ee0ff;
  border-radius:15px;
  padding:12px 18px;
  color:#fff;
  font-size:16px;
  text-align:center;
  backdrop-filter:blur(4px);
  box-shadow:0 4px 10px rgba(0,0,0,0.3);
  z-index: 4000;
">
  💬 <span id="socratesPopupText"></span>
</div>

<script>
window.addEventListener('load', () => {
  try {
    fetch("/api/score?warmup=1", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        transcript: "ok",
        mission: { title: "-", question: "-" },
        warmup: true
      })
    }).catch(() => {});
  } catch (e) {}
});
</script>

<!-- === MANUAL SCORING MODAL (προσωρινό) === -->
<div id="manualModal" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.85);
  display:none;
  justify-content:center;
  align-items:center;
  z-index:4000;
  color:white;
  font-family:system-ui,Arial;
  text-align:center;
  padding:20px;
">
  <div style="
    background:#1a357a;
    border-radius:20px;
    padding:30px;
    max-width:500px;
    width:100%;
    box-shadow:0 0 30px rgba(0,0,0,0.4);
  ">
    <h2>👤 Ανθρώπινος Κριτής</h2>
    <p>Καταχώρησε τους βαθμούς χειροκίνητα.</p>
    <div id="manualInputs" style="margin-top:15px;"></div>
    <div style="margin-top:25px;">
      <button id="manualSubmit" style="background:#6ee0ff;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;color:#001;font-weight:bold;">Καταχώρηση</button>
      <button id="manualCancel" style="background:#ef476f;border:none;padding:10px 20px;border-radius:8px;cursor:pointer;color:#fff;font-weight:bold;margin-left:10px;">Άκυρο</button>
    </div>
  </div>
</div>
<!-- === Version Tag === -->
<div id="versionTag"
     style="
       position: fixed;
       bottom: 6px;
       right: 10px;
       color: #fff;
       font-size: 13px;
       opacity: 0.9;
       font-family: monospace;
       background: rgba(0,0,0,0.6);
       padding: 3px 8px;
       border-radius: 6px;
       z-index: 999999;
     ">
</div>

<script>
  const currentVersion = "v1.3-stable";
  document.getElementById("versionTag").textContent = currentVersion;
  console.log("✅ Έκδοση εμφανίστηκε:", currentVersion);
</script>

    <script>
window.addEventListener("DOMContentLoaded", () => {
  const simpleBtn = document.getElementById("startSimpleBtn");
  const advancedBtn = document.getElementById("startAdvancedBtn");
  const infoBtn = document.getElementById("infoButton");

  if (simpleBtn) {
    simpleBtn.addEventListener("click", () => startGame("simple"));
  }
  if (advancedBtn) {
    advancedBtn.addEventListener("click", () => startGame("advanced"));
  }
  if (infoBtn) {
    infoBtn.addEventListener("click", () => {
      alert("📜 Οδηγίες Παιχνιδιού:\n\n1️⃣ Επίλεξε παίκτες και γύρους.\n2️⃣ Μίλα ή γράψε την απάντηση του παίκτη.\n3️⃣ Ο Σωκράτης θα τη βαθμολογήσει και θα σχολιάσει.\n\nΚαλή διασκέδαση!");
    });
  }

  console.log("✅ Τα κουμπιά της αρχικής σελίδας ενεργοποιήθηκαν.");
});

/* ==========================================================
   🎲 ΚΟΥΜΠΙ ΠΑΡΑΔΕΙΓΜΑ + ΑΥΤΟΜΑΤΗ ΑΞΙΟΛΟΓΗΣΗ ΣΩΚΡΑΤΗ
   ========================================================== */

/* ---------- Ενεργοποίηση Κάρτας Παραδείγματος + Αυτόματη Αξιολόγηση ---------- */
async function showExample() {
  try {
    const missionId = currentMissionId || "M-101";
    const words = await loadExampleWords(missionId);

    if (words.length === 0) {
      alert("Δεν υπάρχουν διαθέσιμες κάρτες παραδειγμάτων για αυτή την αποστολή.");
      return;
    }

    // 🎲 Τυχαία επιλογή μιας 3άδας λέξεων
    const trio = words[Math.floor(Math.random() * words.length)];
    const exampleText = `🎲 Οι λέξεις σου είναι: ${trio.join(" – ")}`;
    console.log(exampleText);
    alert(exampleText);

    // 🎙️ Ενεργοποίηση φωνητικής αναγνώρισης
    if (typeof startSpeechRecognition === "function") {
      console.log("🎤 Ενεργοποιείται η φωνητική αναγνώριση για το Παράδειγμα...");
      startSpeechRecognition(async (spokenText) => {

        console.log("🗣️ Παράδειγμα που ειπώθηκε:", spokenText);

        // ✨ Στέλνουμε μόνο το Παράδειγμα για αξιολόγηση στον Σωκράτη
        const feedback = await getExampleFeedback(spokenText, trio);

        alert(`💬 Σωκράτης: ${feedback}`);
      });
    } else {
      console.warn("⚠️ Δεν βρέθηκε η συνάρτηση startSpeechRecognition().");
    }

  } catch (err) {
    console.error("⚠️ Σφάλμα κατά την εμφάνιση κάρτας παραδείγματος:", err);
  }
}


/* ---------- Σωκρατική Αξιολόγηση Παραδείγματος ---------- */
async function getExampleFeedback(spokenText, trioWords) {
  try {
    const prompt = `
Είσαι ο φιλόσοφος Σωκράτης.
Ο μαθητής μόλις έδωσε ένα παράδειγμα χρησιμοποιώντας τις λέξεις: ${trioWords.join(", ")}.
Αξιολόγησέ το σύντομα (1 πρόταση) αν το παράδειγμα σχετίζεται ουσιαστικά με αυτές τις έννοιες.
Να απαντήσεις ως "Σωκράτης" με θετικό ή διορθωτικό τόνο, χωρίς αριθμούς.
Παράδειγμα μαθητή: "${spokenText}"`;

    const response = await fetch("/api/score", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        transcript: spokenText,
        mission: { question: "Αξιολόγησε μόνο τη χρήση του παραδείγματος" },
        mode: "example"
      })
    });

    if (!response.ok) {
      console.error("❌ API error για Παράδειγμα:", response.status);
      return "Δεν κατάλαβα πλήρως το παράδειγμά σου — για προσπάθησε ξανά!";
    }

    const data = await response.json();
    console.log("📨 Απάντηση Σωκράτη (Παράδειγμα):", data);
    return data.feedback || "Καλή αρχή, αλλά χρειάζεται πιο σαφής σύνδεση.";
  } catch (err) {
    console.error("⚠️ Σφάλμα αξιολόγησης παραδείγματος:", err);
    return "Ο Σωκράτης συλλογίζεται ακόμη το παράδειγμα...";
  }
}

      
</script>

</body>
</html>

